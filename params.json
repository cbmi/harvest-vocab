{"name":"Harvest-vocab","tagline":"Abstract models and manager for querying hierarchical data for Harvest","body":"Harvest-Vocab provides a set of abstract Django models for making it trivial to query hierarchical data. Most database systems do not have operators supporting [logical conjunction](http://en.wikipedia.org/wiki/Logical_conjunction) _across multiple rows_. The `IN` operator is [disjunctive](http://en.wikipedia.org/wiki/Logical_disjunction) since only one of _operands_ must be true to satisfy the truth. Harvest-Vocab provides support for constructing _conjunctive_ queries (and the negation of that) as well as _exclusive conjunctive_ queries. The query generation are exposed using Django manager methods.\r\n\r\nIn addition, hooks are for integrating with [Harvest](http://harvest.research.chop.edu) applications including an Avocado Translator which support defines Avocado operators that map to the manager methods for constructing these kinds of queries. This can be used with the [Harvest-Vocab Client](https://github.com/cbmi/harvest-vocab-client) which integrates with the [Cilantro](http://cilantro.harvest.io), the official client of Harvest.\r\n\r\n## Introduction\r\n\r\nHarvest-Vocab provides abstract models for defining vocabulary-like models and building a corresponding index for hierarchical data.\r\n\r\nFor example, this is how you could define models for storing [ICD9 codes](http://en.wikipedia.org/wiki/List_of_ICD-9_codes):\r\n\r\n```python\r\nfrom vocab.models import AbstractItem\r\n\r\nclass Diagnosis(AbstractItem):\r\n    code = models.CharField(max_length=10)\r\n    description = models.CharField(max_length=50)\r\n    parent = models.ForeignKey('self', related_name='children')\r\n```\r\n\r\nICD9 codes are hierachical therefore when I ask the questions, _\"Give me all the patients who have a diagnosis of ICD9 367 (Disorders of refraction and accommodation)\"_, then this should not only query 367, but all descendent diagnoses as well (which includes another 2 levels).\r\n\r\nThis kind of query becomes difficult to write (using the Django ORM or raw SQL) since only the direct parent of the a particular diagnosis is accessible for a given diagnosis, thus the query would look like this.\r\n\r\n```python\r\nfrom django.db.models import Q\r\n\r\ncondition = Q(code='367') | Q(parent__code='367')\r\nDiagnosis.objects.filter(condition)\r\n```\r\n\r\nThe obvious problem here is that any diagnoses 2+ levels down from '367' are not included.\r\n\r\n### Flat Index\r\n\r\nTo alleviate this issue, we build a flat index for all levels of the hierarchy. Define it like this:\r\n\r\n```python\r\nfrom vocab.models import AbstractItemIndex\r\n\r\nclass DiagnosisIndex(AbstractItemIndex):\r\n    item = models.ForeignKey(Diagnosis, related_name='item_indexes')\r\n    parent = models.ForeignKey(Diagnosis, related_name='parent_indexes')\r\n\r\n\r\nDiagnosisIndex.objects.index()\r\n```\r\n\r\nThe last line builds a flat index of the hierarchy which alleviates the depth issue. So now, the same question stated above can be answered this way (using the same condition from above):\r\n\r\n```python\r\nsubquery = DiagnosisIndex.objects.filter(condition)\r\ndiagnoses = Diagnosis.objects.filter(id__in=subquery)\r\n```\r\n\r\nThis utilizes the index and returns all diagnoses that match the condition explictly or are descedents of the ICD9 code of interest.\r\n\r\n## Operators\r\n\r\nThe only native multi-row operator SQL supports is `IN`. A row will be returned if it matches _any_ of the values in the `IN` tuple. However there is no native operator for requiring _all_, _not all_ and _only_.\r\n\r\nHarvest-Vocab defines four operators to support these kinds of queries and exposes them via the `ItemThroughManager` class.\r\n\r\n- `requires_any(values)` - Corresponds to the `IN` clause (defined for completeness)\r\n- `excludes_any(values)` - Corresponds to the `NOT IN` clause\r\n- `requires_all(values)` - Requires all values to match\r\n- `excludes_all(values)` - Requires all vlaues to _not_ match\r\n- `only(values)` - Matches if the object _only_ contains the specified values\r\n\r\n## Get Started\r\n\r\n### Install\r\n\r\n```bash\r\npip install harvest-vocab\r\n```\r\n\r\n### Setup\r\n\r\n#### Define the Models\r\n\r\n```python\r\nfrom vocab.models import AbstractItem\r\n\r\n# Subclass AbstractItem with your model of interest. Add a ManyToManyField\r\n# to the target object this hierarchy is related to.\r\nclass Diagnosis(AbstractItem):\r\n    patients = models.ManyToManyField(Patient, through='PatientDiagnosis')\r\n    ...\r\n\r\n# Create a many-to-many through model with the correct foreign keys\r\nclass PatientDiagnosis(models.Model):\r\n    diagnosis = models.ForeignKey(Diagnosis)\r\n    patient = models.ForeignKey(Patient)\r\n    ...\r\n\r\n    # pass the field names of the term (diagnosis) and related object (patient)\r\n    objects = ItemThroughManager('diagnosis', 'patient')\r\n\r\n# Create the index model. Note the foreign keys must be named exactly\r\n# as show below including the related_name fields\r\nclass DiagnosisIndex(AbstractItemIndex):\r\n    item = models.ForeignKey(Diagnosis, related_name='item_indexes')\r\n    parent = models.ForeignKey(Diagnosis, related_name='parent_indexes')\r\n```\r\n\r\n#### Build the Index\r\n\r\nThis builds a simple item/ancestor index which enables querying the underlying data as a flat structure. **Note: the index must be rebuild every time the data changes in target model, e.g. `Diagnosis` in this case.**\r\n\r\n```python\r\n>>> DiagnosisIndex.objects.index()\r\n```\r\n\r\nNow that the index has been built the `PatientDiagnosis` manager methods can now be used.\r\n\r\n### Harvest Integration\r\n\r\nHarvest-Vocab comes bundled with a custom Avocado translator which exposes custom operators corresponding to the above manager methods. The translator must be subclassed and the `through_model` class attribute must be set:\r\n\r\n```python\r\nfrom avocado import translators\r\nfrom vocab.translators import VocabularyTranslator\r\nfrom myapp.models import PatientDiagnosis\r\n\r\nclass DiagnosisTranslator(VocabularyTranslator):\r\n    through_model = PatientDiagnosis\r\n\r\ntranslators.register(DiagnosisTranslator)\r\n```\r\n\r\nTo support the [harvest-vocab-client](https://github.com/cbmi/harvest-vocab-client/), endpoints must be defined for the client components to query. Include the `vocab.urls` in the `ROOT_URLCONF` patterns:\r\n\r\n```python\r\nfrom django.conf.urls import url, reverse, patterns\r\n\r\nurlpatterns = patterns('',\r\n    # Other url patterns...\r\n\r\n    url(r'^vocab/', include('vocab.urls')),\r\n)\r\n```\r\n\r\nIn addition, define the `VOCAB_FIELDS` setting which is a list/tuple of Avocado field IDs that are supported.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}